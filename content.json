{"meta":{"title":"伊萨格","subtitle":null,"description":"黄嘉，伊萨格的博客","author":"伊萨格","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"使用 supervisor","slug":"使用 supervisor","date":"2020-07-20T03:31:41.689Z","updated":"2020-07-20T03:36:11.186Z","comments":true,"path":"2020/07/20/使用 supervisor/","link":"","permalink":"http://yoursite.com/2020/07/20/%E4%BD%BF%E7%94%A8%20supervisor/","excerpt":"","text":"​ Node.js 实现的 HTTP 应用时会发现，无论你修改了代码的哪一部份，都必须终止​ Node.js 再重新运行才会奏效。这是因为 Node.js 只有在第一次引用到某部份时才会去解析脚本文件，以后都会直接访问内存，避免重复载入，而 PHP 则总是重新读取并解析脚本（如果没有专门的优化配置）。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。supervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。使用方法很简单，首先使用 npm 安装 supervisor： 1npm install -g supervisor ​ 如果你使用的是 Linux 或 Mac，直接键入上面的命令很可能会有权限错误。原因是 npm​ 需要把 supervisor 安装到系统目录，需要管理员授权，可以使用 sudo npm install -gsupervisor 命令来安装。接下来，使用 supervisor 命令启动 http.js 1supervisor http.js 当代码被改动时，运行的脚本会被终止，然后重新启动.","categories":[],"tags":[]},{"title":"Object.defineProperty","slug":"Object.defineProperty","date":"2020-07-17T01:56:32.056Z","updated":"2020-07-17T03:34:37.568Z","comments":true,"path":"2020/07/17/Object.defineProperty/","link":"","permalink":"http://yoursite.com/2020/07/17/Object.defineProperty/","excerpt":"","text":"语法 Object.defineProperty(obj, key, descriptor) 参数1：目标对象 参数2：要定义或修改的属性的键名 参数3：要定义或修改的属性特性描述 属性1：Vlaue 属性2：writable 属性3：enumerable 属性4：configurable 返回值：传递过去的Object 案例1.Vlaue该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 1234567891011var obj = &#123; name: \"哈哈\"&#125;Object.defineProperty(obj, \"name\", &#123; value: '这是名字'&#125;)console.log(obj)var obj2 = &#123;&#125;Object.defineProperty(obj2, \"name\", &#123;&#125;)console.log(obj2) 输出结果： 2.writable属性 该对象的该属性能否被重写 12345678910111213141516171819var obj = &#123; name: '张三', sex: '男' &#125;Object.defineProperty(obj, \"sex\", &#123; writable: false&#125;)obj.sex = \"女\"console.log(obj)var obj2 = &#123; name: '张三', sex: '男' &#125;Object.defineProperty(obj2, \"sex\", &#123; writable: true&#125;)obj2.sex = \"女\"console.log(obj2)//网上看到说默认为false,不清楚咋回事,如果不写该属性对象的值也可以改变var obj3 = &#123; name: '张三', sex: '男' &#125;Object.defineProperty(obj3, \"sex\", &#123;&#125;)obj3.sex = \"女\"console.log(obj3) 输出结果： 3.enumerable 此属性是否可以被枚举，设置为false之后不可以枚举，但可以访问，也可以更改 1234567891011var obj = &#123; \"1\": \"1\", \"2\": \"2\", \"3\": \"3\"&#125;Object.defineProperty(obj, \"2\", &#123; enumerable: false&#125;)obj[\"2\"] = 20console.log(Object.keys(obj))//[\"1\",\"3\"]console.log(obj[\"2\"])//20 4.configurable 作用1：是否可以使用delete删除目标属性 作用2：目标属性是否可以再次设置特性 1234567891011121314151617181920212223var obj = &#123; \"1\":\"1\", \"2\":\"2\", \"3\":\"3\"&#125;Object.defineProperty(obj,\"2\",&#123; configurable:false&#125;)// 测试是否可以被删除delete obj[\"2\"]obj[\"2\"] = \"可以修改？\"console.log(obj)try&#123;//捕获错误 Object.defineProperty(obj,\"2\",&#123; configurable:true &#125;)&#125;catch(err)&#123; console.dir(err)&#125;delete obj[\"2\"]console.log(obj) 输出结果： 由图可以得出，当configurable设置为false的时候，属性值不可以被删除，并且不可以再次修改特性，如果修改会报错，但是属性的值依旧可以改变。","categories":[],"tags":[]},{"title":"element-ui树表格懒加载动态更新数据","slug":"element-ui树表格懒加载动态更新数据","date":"2020-07-16T09:53:35.126Z","updated":"2020-07-16T09:56:15.518Z","comments":true,"path":"2020/07/16/element-ui树表格懒加载动态更新数据/","link":"","permalink":"http://yoursite.com/2020/07/16/element-ui%E6%A0%91%E8%A1%A8%E6%A0%BC%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195&lt;template&gt; &lt;div class=\"home\"&gt; &lt;div class=\"app-page-header\"&gt;&lt;/div&gt; &lt;div class=\"app-page-content deepBox\"&gt; &lt;el-table ref=\"table\" :data=\"tableData\" style=\"width: 100%;margin-bottom: 20px;\" row-key=\"areaId\" border :load=\"load\" :lazy=\"true\" :tree-props=\"&#123;children: 'children', hasChildren:'hasChildren'&#125;\" &gt; &lt;!-- :expand-row-keys=\"expandRowKeys\" --&gt; &lt;el-table-column width=\"60\" align=\"center\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;span v-show=\"!scope.row.hasChildren\"&gt;-&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"name\" label=\"区域名称\" width=\"100\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-link type=\"primary\" @click=\"$router.push(`serverList/$&#123;scope.row.areaId&#125;`)\" &gt;&#123;&#123;scope.row.name&#125;&#125;&lt;/el-link&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"childCount\" label=\"子区域数\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"dnai\" label=\"标识符\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"ruleCount\" label=\"服务器数\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"createdAt\" label=\"加入时间\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"ruleCount\" label=\"关联策略数\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"ruleCount\" label=\"操作\" width=\"200\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-button-group&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\" size=\"mini\" @click=\"addReg(scope.row)\"&gt;&lt;/el-button&gt; &lt;el-button type=\"danger\" icon=\"el-icon-close\" size=\"mini\" @click=\"del(scope.row)\"&gt;&lt;/el-button&gt; &lt;el-button type=\"primary\" icon=\"el-icon-edit\" size=\"mini\" @click=\"edit(scope.row)\"&gt;&lt;/el-button&gt; &lt;el-button type=\"primary\" icon=\"el-icon-tickets\" size=\"mini\"&gt;&lt;/el-button&gt; &lt;/el-button-group&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;addRegional :dialogVisible.sync=\"regionalAddVisible\" :parentList=\"tableData\" :regIdVal=\"regIdVal\" @sonAddEvent=\"sonAddEvent\" :edit=\"isEdit\" ref=\"addReg\" &gt;&lt;/addRegional&gt; &lt;addServer :dialogVisible.sync=\"serverAddVisible\"&gt;&lt;/addServer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import &#123; Component, Vue &#125; from \"vue-property-decorator\";import PageHead from \"@/components/PageHead/index.vue\";import addRegional from \"./components/addRegional.vue\";import addServer from \"./components/addServer.vue\";import &#123; resource_areas_add &#125; from \"@/api/regionalManagement\";import &#123; resource_areas_list, resource_areas_del&#125; from \"@/api/regionalManagement\";@Component(&#123; name: \"RegionalManagement\", components: &#123; PageHead, addRegional, addServer &#125;&#125;)export default class RegionalManagement extends Vue &#123; $refs!: &#123; table: HTMLFormElement; addReg: HTMLFormElement; &#125;; currentPage1 = 1; regionalAddVisible = false; serverAddVisible = false; expandRowKeys: number[] = []; tableData: any = []; total: number = 0; maps = new Map(); //缓存数据 RowObject:any = &#123;&#125;; //标记操作行对象 isEdit:boolean=false; regIdVal = &#123; id: \"\", val: \"\" &#125;; created() &#123; this.getList(); &#125; //请求列表 async getList(pid: number = 0) &#123; let res = await resource_areas_list(&#123; parentId: pid &#125;); this.tableData = this.addHasChildren(res.areas); this.maps.set(0,this.tableData) console.log(this.maps) console.log(this.tableData); &#125; //添加树区域符号判断 addHasChildren(arr: any) &#123; return arr.map((item: any) =&gt; Object.assign(item, &#123; hasChildren: item.childCount &gt; 0 &#125;) ); &#125; //懒加载数据点击加号触发 async load(tree: any, treeNode: Object, resolve: Function) &#123; let areaId = tree.areaId; //保存数据，参数1是当前展开的id作为标识符便于查找，参数2是对应的对象 this.maps.set(areaId, tree); console.log(this.maps); let res = await resource_areas_list(&#123; parentId: tree.areaId &#125;); let arr = this.addHasChildren(res.areas); resolve(res.areas); &#125; //删除 async del(object: any) &#123; let p = await this.$confirm(\"确认删除该区域吗?\", \"提示\", &#123; confirmButtonText: \"确定\", cancelButtonText: \"取消\", type: \"warning\" &#125;); if (p == \"confirm\") &#123; let res = await resource_areas_del(&#123; areaId: object.areaId &#125;); this.$message(&#123; type: \"success\", message: \"删除成功!\" &#125;); //删除的时候找父节点更新本身列表，然后找到父节点的父节点更新自己本身 //需要更新父所以从缓存的地方找到父的父节点去更新父 let parentId = this.maps.get(object.parentId).parentId //更新父节点从而触发本身所在数组发生变化 let areaId = this.maps.get(object.parentId).areaId this.upData(areaId,parentId) &#125; &#125; //获取子组件返回数据，然后进行添加 async sonAddEvent(from_date: any) &#123; //提交请求 let res = await resource_areas_add(from_date); //关闭组件 this.regionalAddVisible = false; this.$message(&#123; type: \"success\", message: \"添加成功!\" &#125;); let areaId = this.RowObject.areaId//获取添加行的id let parentId = this.RowObject.parentId?this.RowObject.parentId:0//获取操作行的父id this.upData(areaId,parentId);//通过子父节点更新数据 &#125; async upData(id: number, pid?: number) &#123; //更新父 if (pid) &#123; console.log(\"有父节点\") let res = await resource_areas_list(&#123; parentId: pid &#125;); let list = this.addHasChildren(res.areas) this.$set(this.$refs.table.store.states.lazyTreeNodeMap, pid, list); &#125;else&#123; console.log(\"没有父节点所以重新请求列表\") this.getList(); &#125; //更新子 if (this.maps.has(id)) &#123; console.log(\"更新子节点数组,id是\"+id) let res = await resource_areas_list(&#123; parentId: id &#125;); //再次请求获取当前数据 let list = this.addHasChildren(res.areas)//处理数据 this.$set(this.$refs.table.store.states.lazyTreeNodeMap, id, list);//将当前数据重新push &#125;else&#123;//如果最外层更新顶级 console.log(\"最外层，所以更新父节点\") this.getList(); &#125; &#125; edit(object: any) &#123; this.regionalAddVisible = true; this.isEdit = true &#125; addReg(object: any) &#123; //给子组件传值 this.regionalAddVisible = true; if (!object) &#123; this.RowObject = &#123;&#125;; this.regIdVal.id = \"\"; this.regIdVal.val = \"\"; return; &#125; this.RowObject = object; //获取行id存储 this.regIdVal.id = object.areaId; this.regIdVal.val = object.name; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt;","categories":[],"tags":[]},{"title":"简单版Promise封装","slug":"简单版Promise封装","date":"2020-07-07T06:37:48.729Z","updated":"2020-07-07T06:43:40.362Z","comments":true,"path":"2020/07/07/简单版Promise封装/","link":"","permalink":"http://yoursite.com/2020/07/07/%E7%AE%80%E5%8D%95%E7%89%88Promise%E5%B0%81%E8%A3%85/","excerpt":"","text":"函数作为参数传给函数123456789function Pro(fn)&#123;//1首先声明了一个pro函数,pro函数接收一个函数作为参数 var value = 100 fn(value)//3然后再Pro里面执行了传递过来的函数，并且给此函数传递了一个参数，这样就可以在Pro执行的时候拿到里面的数据&#125;Pro(function(value)&#123;//2然后我们执行pro函数，传递给它一个匿名函数 console.log(\"fn执行了\") console.log(\"value是:\"+value)&#125;) 首先声明了一个pro函数,pro函数接收一个函数作为参数 然后我们执行pro函数，传递给它一个匿名函数 然后再Pro里面执行了传递过来的函数，并且给此函数传递了一个参数，这样就可以在Pro执行的时候拿到里面的数据 构造函数版本12345678910111213function Pro(fn) &#123;//1首先声明了一个pro构造函数,pro构造函数接收一个函数作为参数 this.init(fn)//3.初始化&#125;Pro.prototype = &#123; constructor: Pro, init(fn) &#123; fn(5000)//4执行实例化传递过来的fn方法并且穿一个实参5000 &#125;&#125;let p = new Pro(function (res) &#123;//2实例化Pro传递一个函数作为参数 //假设我们现在需要在这里拿到res的值 console.log(res)&#125;) 加入异步操作123456789101112131415161718function Pro(fn)&#123; this.init(fn)&#125;Pro.prototype=&#123; constructor:Pro, init(fn)&#123; fn(this.res)//4.改变执行时的传惨，把res方法传递给实例化对象 &#125;, res(value)&#123;//3.定义一个res方法 console.log(value) &#125;&#125;let p = new Pro(function(res)&#123; setTimeout(function()&#123;//1.改写为异步操作并且执行res,那么这次的res就不是数值，也是一个函数了 var vlue = parseInt(Math.random()*500) res(vlue)//2.我们现在执行这个函数，这样就可以在异步里面拿到这个参数 &#125;,1000)&#125;) 现在我们需要在构造函数里拿到异步操作之后的值，假设setTimeout是一个网络请求，value是网网络请求之后的结果 此时的res就是构造函数的res,我们在初始化的时候执行fn方法,然后把res方法作为参数传递给实例化对象的函数的参数了。 然后执行res方法,把vlaue传递给构造函数，此时就可以在构造函数里面的res方法里拿到value的值了 用.then来实现链式调用123456789101112131415161718192021222324function Pro(fn)&#123; this.init(fn)&#125;Pro.prototype=&#123; constructor:Pro, fns:[], init(fn)&#123; fn(this.res.bind(this)) &#125;, res(value)&#123; this.fns.forEach(fns=&gt;fns(value)) &#125;, then(res)&#123; this.fns.push(res) &#125;&#125;let p = new Pro(function(res)&#123; setTimeout(function()&#123; var vlue = parseInt(Math.random()*500) res(vlue) &#125;,1000)&#125;).then(res=&gt;&#123; console.log(res)&#125;) .then接收的也是一个函数，但是我们是异步执行的，所以每次.then的时候用一个数组把传递过去的方法存起来，然后在res执行的时候执行传递过去的.then方法并且把vlaue传过去。这样就实现了链式调用。","categories":[],"tags":[]},{"title":"vue-axios跨域请求方法","slug":"vue-axios跨域请求方法","date":"2020-06-15T09:51:27.875Z","updated":"2020-06-15T15:05:23.663Z","comments":true,"path":"2020/06/15/vue-axios跨域请求方法/","link":"","permalink":"http://yoursite.com/2020/06/15/vue-axios%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/","excerpt":"","text":"vue-axios跨域 基本环境 *”axios”*: “^0.19.2”, *”body-parser”*: “^1.19.0”, *”cookie-parser”*: “^1.4.5”, *”echarts”*: “^4.8.0”, *”element-ui”*: “^2.13.2”, *”express”*: “^4.17.1”, *”multer”*: “^1.4.2”, *”vue”*: “^2.5.2”, *”vue-axios”*: “^2.1.5”, *”vue-router”*: “^3.0.1” 示例接口： 本地端口：http://localhost:8083/ 跨域端口：https://iflow-api.uc.cn/feiyan/special（此接口是新冠病毒数据接口地址） 解决方案 第一步来到 main.js 中，加入以下配置项： 1234567891011121314151617181920212223242526import Vue from 'vue'import App from './App'import router from './router'import ElementUI from 'element-ui';import ajax from '@/request/ajax'import 'element-ui/lib/theme-chalk/index.css';import echarts from 'echarts';Vue.prototype.$ajax = ajax//跨域配置,此地的ajax只是一个命名,实际上是自己做过修改的axiosajax.defaults.baseURL = '/api'ajax.defaults.headers.post['Content-Type'] = 'application/json';Vue.config.productionTip = falseVue.prototype.$echarts = echarts;Vue.use(ElementUI, &#123; size: 'medium', zIndex: 2000&#125;);/* eslint-disable no-new */new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) 配置 config 文件下的 index.js ，找到 proxyTable 在此对象中加入以下代码： 123456'/api': &#123; target:'https://iflow-api.uc.cn/feiyan', // 你请求的第三方接口 changeOrigin:true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite:&#123; // 路径重写， '^/api': '' // 替换target中的请求地址，也就是说以后你在请求`https://iflow-api.uc.cn/feiyan/XXXXX这个地址的时候直接写成/xxxx即可。 &#125; 请求示例： 12345678910111213141516//本来请求地址是https://iflow-api.uc.cn/feiyan/special,现在只用写/specialthis.$ajax.get('/special',&#123; 'uc_param_str': 'pccplomi', 'feiyan': '1', 'district': '1', 'tabStart': '0', 'tabEnd': '1', 'tabBrief':'1', 'aid': '3804775841868884355' &#125;).then(res=&gt;&#123;//处理数据 this.list = res.data.data.feiyan.provinces.map(item=&gt;&#123; return Object.assign(item,&#123;sum:item.sure_cnt-item.die_cnt-item.cure_cnt&#125;) &#125;).sort((item,item2)=&gt;&#123; return item2.sure_cnt-item.sure_cnt &#125;) &#125;) 然后执行请求可以看到本来是https://iflow-api.uc.cn/feiyan/special的现在变成了http://localhost:8083/api/special 也就是说经过这个配置 api替换了config文件下 index.js中target值的地址去开启一个代理，然后访问此路径下的所有接口都只用从https://iflow-api.uc.cn/feiyan/special之后开使写就行了。","categories":[],"tags":[]},{"title":"npm常用方式","slug":"npm常用方式","date":"2020-06-13T10:32:07.732Z","updated":"2020-06-13T10:31:45.375Z","comments":true,"path":"2020/06/13/npm常用方式/","link":"","permalink":"http://yoursite.com/2020/06/13/npm%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/","excerpt":"","text":"npm使用方式1.npm常用命令 npm init npm init -y //可以跳过向导，快速生成 npm install npm install //一次性把 dependencies选项中的依赖全部安装 npm install 包名 npm install 包名 –save //下载并且保存依赖 简写:npm i 包名 -S 或者npm i -S 包名 npm uninstall 包名 只删除，如果有依赖项依然会保存 npm uninstall –save 包名 删除同时把依赖信息也去除 简写：npm un -S 包名 npm help npm install help //查看install使用帮助 解决 npm 被墙的问题npm 的存储包放在国外，有时候会被墙，所以下载速度很慢，可以下载 cnpm解决 安装淘宝的cnpm(在任意目录下都可以): 1npm install -g cnpm --registry=https://registry.npm.taobao.org 接下来你安装包的时候把之前的 npm 替换成 cnpm 使用案例，比如安装jquery： 123npm i jquery//变为cnpm i jquery 如果不想安装 cnpm 又想使用淘宝的服务器来下载: 1npm install jquery --registry=https://registry.npm.taobao.org 但是每次都这样手动去加很麻烦，我们可以把这个选项加入配置文件中： 1npm config set registry=https://registry.npm.taobao.org 安装完成之后使用 npm config list 查看配置信息，成功后你使用所有的 npm install 都会使用淘宝的服务器来下载。","categories":[],"tags":[]}],"categories":[],"tags":[]}