{"meta":{"title":"伊萨格","subtitle":null,"description":"黄嘉，伊萨格的博客","author":"伊萨格","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"nodeJS爬虫初探","slug":"nodeJS爬虫初探","date":"2020-09-29T01:56:40.654Z","updated":"2020-09-29T07:30:18.480Z","comments":true,"path":"2020/09/29/nodeJS爬虫初探/","link":"","permalink":"http://yoursite.com/2020/09/29/nodeJS%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/","excerpt":"","text":"模块依赖话不多说直接上安装代码 + npm install cheerio --save + npm install html-entities --save + npm install iconv-lite --save + npm install request --save初步爬取爬取目标网站：http://www.biquge.info 笔趣阁小说网，随便找的 12345var request = require('request')var url = \"http://www.biquge.info/\"let a = request(url, (error, response, body) =&gt; &#123; console.log(body)&#125;) 爬取结果： 直接乱码了 请求目标网站太过直接了 接下来把request请求网页的方式变更一下 分析目标网页的请求 Accept-Encoding，HTTP Header中Accept-Encoding 是浏览器发给服务器,声明浏览器支持的编码类型 gzip是若干种文件压缩程序的简称（没深入研究） 重写爬取 1234567891011var url = \"http://www.biquge.info/\"let a = request(&#123; url: url, method: 'get', gzip:true,//配置gzip属性 headers:&#123;//配置headers \"Accept-Encoding\": \"gzip,deflate\"//模拟请求头好像没用，具体原因不明，还是需要gzip属性 &#125;&#125;, (error, response, body) =&gt; &#123; console.log(body)&#125;) 输出结果非常不错，是自己想要的东西了 使用cheerio 模块解析HTMLcheerio 模块可以在服务器端使用JQuery的方式操作DOM结构,大部分用法和jquery 相似 具体用法参考百度：https://baike.baidu.com/item/cheerio/17031205?fr=aladdin 继续分析目标网页 可以看到排行榜单的小说最多，那么换排行榜单下手 改写代码 1234567891011121314151617181920var request = require('request')var cheerio = require('cheerio')//引入cheerio模块var url = \"http://www.biquge.info/paihangbang_allvisit/1.html\"//请求地址变成了榜单第一页let a = request(&#123; url: url, method: 'get', gzip:true, headers:&#123; \"Accept-Encoding\": \"gzip,deflate\" &#125;&#125;, (error, response, body) =&gt; &#123; let $ = cheerio.load(body); //分析网页接口，小说的标题久存放在novelslistss li .s2 a的A里面 let arr = $('.novelslistss li .s2 a').map((idx, elel) =&gt; &#123; return &#123;//输出你想要的数据 name:$(elel).text() &#125; &#125;).get()//处理类数组.一定要.get,vue用多了就吃jq的亏 console.log(arr)&#125;) 输出结果不错，起码名字都出来了，校花的贴身高手，好牛逼的样子 封装函数仅仅一个标题没什么好看的，接下来爬取指定页到指定页的小说合集，并且带上其他的信息 分析翻页可以看出 爬取目标的url地址是http://www.biquge.info/paihangbang_allvisit/${当前页}.html 小说的基本信息都可以在类名为novelslistss中的每个li找到 1234567891011121314151617181920212223242526272829303132333435363738var cheerio = require('cheerio')var request = require('request')/*爬取指定页(递归函数) *@param&#123;startPage&#125; 从哪一页开始 *@param&#123;startPage&#125; 到哪一页结束 *@return &#123;undefined&#125; 无返回值 */function getNovel(startPage, endPage) &#123; var url = `http://www.biquge.info/paihangbang_allvisit/$&#123;startPage&#125;.html` console.log(`开始爬取第$&#123;startPage&#125;页`) let res = request(&#123; url: url, method: 'get', gzip: true, headers: &#123; \"Accept-Encoding\": \"gzip,deflate\" &#125; &#125;, (error, response, body) =&gt; &#123; let $ = cheerio.load(body); let arr = $('.novelslistss li').map((idx, elel) =&gt; &#123; return &#123; type: $(elel).children('.s1').text(),//类型 name:$(elel).children('.s2').text(),//小说名称 url:$(elel).children('.s2').children('a').attr('href'),//获取地址 author:$(elel).children('.s4').text(),//作者 state:$(elel).children('.s7').text()//状态 &#125; &#125;).get() console.log(`$&#123;startPage&#125;页爬取成功,数据如下`) console.log(...arr.map(item=&gt;item.name+\"|\")) if(startPage===endPage) return;//当开始爬取的页面等于结束页的时候return出去 console.log(\"开始爬取下一页\"); getNovel(startPage+1,endPage) &#125;)&#125;getNovel(1,10) 爬取结果 关于爬虫的合法性 遵守 Robots 协议，但有没有 Robots 都不代表可以随便爬，可见下面的大众点评百度案； 限制你的爬虫行为，禁止近乎 DDOS 的请求频率，一旦造成服务器瘫痪，约等于网络攻击； 对于明显反爬，或者正常情况不能到达的页面不能强行突破，否则是 Hacker 行为； 最后，审视清楚自己爬的内容，以下是绝不能碰的红线（包括但不限于）： 爬取用户个人数据非法牟利，包括模拟登录他人账号，如下一案例中操作账号加粉 新三板挂牌公司涉窃取30亿条个人信息，非法牟利超千万 爬取商业数据造成不正当竞争，如下一案例中破解并监控竞品 GPS 数据 竞争燃藜·深圳中院|利用网络爬虫技术攫取他人数据正当性认定 爬取大量带有知识产权的数据用于商业目的，如下一案例中爬取大量视频内容 - 全文页 - 中国裁判文书网 最后附上2014年百度地图因大量引用大众点评的评论被起诉，最后法院的判决也说明遵守 Robots 协议并不是没有问题，大量爬取造成的不正当竞争依然会违法。 大众点评向百度索赔9000万 法院判赔300万 以上你会发现，爬虫本身并不违法，而是看你使用的方式和目的，还要看是不是商业用途。 这就像摄影一样，人人都可以拍照，技术宅也可以用无人机满天拍，但如果你拍人家隐私、在禁区里拍、偷拍盗版人家的作品，对不起那是违法。","categories":[],"tags":[]},{"title":"基于proxy代理不同封装axios","slug":"基于proxy代理不同封装axios","date":"2020-09-28T03:35:26.384Z","updated":"2020-09-28T03:38:21.935Z","comments":true,"path":"2020/09/28/基于proxy代理不同封装axios/","link":"","permalink":"http://yoursite.com/2020/09/28/%E5%9F%BA%E4%BA%8Eproxy%E4%BB%A3%E7%90%86%E4%B8%8D%E5%90%8C%E5%B0%81%E8%A3%85axios/","excerpt":"","text":"需求个人网站，使用了大量的proxy代理请求，基于axios封装，实现每次根据代理匹配不同的网络请求。","categories":[],"tags":[]},{"title":"webpack1","slug":"webpack1","date":"2020-09-14T02:41:36.971Z","updated":"2020-09-14T02:51:17.678Z","comments":true,"path":"2020/09/14/webpack1/","link":"","permalink":"http://yoursite.com/2020/09/14/webpack1/","excerpt":"","text":"webpack的作用：编译 JavaScript 模块,通过 webpack 的 CLI 或 API 与其配合交互 安装webpack:首先创建一个项目目录，使用 npm init初始化项目 12","categories":[],"tags":[]},{"title":"Nuxt使用","slug":"Nuxt使用","date":"2020-08-04T01:54:11.863Z","updated":"2020-08-03T06:57:30.854Z","comments":true,"path":"2020/08/04/Nuxt使用/","link":"","permalink":"http://yoursite.com/2020/08/04/Nuxt%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.安装nuxt123vue init nuxt/starter ssr-blognpm installnpm run dev 2.引入全局CSS把CSS文件放入到static中 来到 nuxt.config.js 加入以下配置 12345678910111213141516171819202122232425262728293031323334353637383940module.exports = &#123; /* ** Headers of the page */ head: &#123; title: 'ssr-blog', meta: [ &#123; charset: 'utf-8' &#125;, &#123; name: 'viewport', content: 'width=device-width, initial-scale=1' &#125;, &#123; hid: 'description', name: 'description', content: 'Nuxt.js project' &#125; ], link: [//这里就是引入CSS的地方 &#123; rel: 'stylesheet', type: 'text/css', href: '/css/common.css' &#125;, &#123; rel: 'stylesheet', type: 'text/css', href: '/css/bootstrap.min.css' &#125;, &#123; rel: 'stylesheet', type: 'text/css', href: '/css/index.css' &#125; ] &#125;, /* ** Customize the progress bar color */ loading: &#123; color: '#3B8070' &#125;, /* ** Build configuration */ build: &#123; /* ** Run ESLint on save */ extend (config, &#123; isDev, isClient &#125;) &#123; if (isDev &amp;&amp; isClient) &#123; config.module.rules.push(&#123; enforce: 'pre', test: /\\.(js|vue)$/, loader: 'eslint-loader', exclude: /(node_modules)/ &#125;) &#125; &#125; &#125;&#125; 3.配置每个页面需要用到的头部跟尾部首先来到components 文件下新建两个组件 topTitle Footer 然后来到 layouts 文件下的 default.vue 配置页面组件 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;topTitle /&gt; &lt;nuxt /&gt; &lt;Footer /&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import topTitle from \"~/components/topTitle.vue\";import Footer from \"~/components/Footer.vue\";export default &#123; components: &#123; topTitle, Footer &#125;,&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;","categories":[],"tags":[]},{"title":"使用 supervisor","slug":"使用 supervisor","date":"2020-07-20T03:31:41.689Z","updated":"2020-07-20T03:36:11.186Z","comments":true,"path":"2020/07/20/使用 supervisor/","link":"","permalink":"http://yoursite.com/2020/07/20/%E4%BD%BF%E7%94%A8%20supervisor/","excerpt":"","text":"​ Node.js 实现的 HTTP 应用时会发现，无论你修改了代码的哪一部份，都必须终止​ Node.js 再重新运行才会奏效。这是因为 Node.js 只有在第一次引用到某部份时才会去解析脚本文件，以后都会直接访问内存，避免重复载入，而 PHP 则总是重新读取并解析脚本（如果没有专门的优化配置）。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。supervisor 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。使用方法很简单，首先使用 npm 安装 supervisor： 1npm install -g supervisor ​ 如果你使用的是 Linux 或 Mac，直接键入上面的命令很可能会有权限错误。原因是 npm​ 需要把 supervisor 安装到系统目录，需要管理员授权，可以使用 sudo npm install -gsupervisor 命令来安装。接下来，使用 supervisor 命令启动 http.js 1supervisor http.js 当代码被改动时，运行的脚本会被终止，然后重新启动.","categories":[],"tags":[]},{"title":"Object.defineProperty","slug":"Object.defineProperty","date":"2020-07-17T01:56:32.056Z","updated":"2020-07-17T03:34:37.568Z","comments":true,"path":"2020/07/17/Object.defineProperty/","link":"","permalink":"http://yoursite.com/2020/07/17/Object.defineProperty/","excerpt":"","text":"语法 Object.defineProperty(obj, key, descriptor) 参数1：目标对象 参数2：要定义或修改的属性的键名 参数3：要定义或修改的属性特性描述 属性1：Vlaue 属性2：writable 属性3：enumerable 属性4：configurable 返回值：传递过去的Object 案例1.Vlaue该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 1234567891011var obj = &#123; name: \"哈哈\"&#125;Object.defineProperty(obj, \"name\", &#123; value: '这是名字'&#125;)console.log(obj)var obj2 = &#123;&#125;Object.defineProperty(obj2, \"name\", &#123;&#125;)console.log(obj2) 输出结果： 2.writable属性 该对象的该属性能否被重写 12345678910111213141516171819var obj = &#123; name: '张三', sex: '男' &#125;Object.defineProperty(obj, \"sex\", &#123; writable: false&#125;)obj.sex = \"女\"console.log(obj)var obj2 = &#123; name: '张三', sex: '男' &#125;Object.defineProperty(obj2, \"sex\", &#123; writable: true&#125;)obj2.sex = \"女\"console.log(obj2)//网上看到说默认为false,不清楚咋回事,如果不写该属性对象的值也可以改变var obj3 = &#123; name: '张三', sex: '男' &#125;Object.defineProperty(obj3, \"sex\", &#123;&#125;)obj3.sex = \"女\"console.log(obj3) 输出结果： 3.enumerable 此属性是否可以被枚举，设置为false之后不可以枚举，但可以访问，也可以更改 1234567891011var obj = &#123; \"1\": \"1\", \"2\": \"2\", \"3\": \"3\"&#125;Object.defineProperty(obj, \"2\", &#123; enumerable: false&#125;)obj[\"2\"] = 20console.log(Object.keys(obj))//[\"1\",\"3\"]console.log(obj[\"2\"])//20 4.configurable 作用1：是否可以使用delete删除目标属性 作用2：目标属性是否可以再次设置特性 1234567891011121314151617181920212223var obj = &#123; \"1\":\"1\", \"2\":\"2\", \"3\":\"3\"&#125;Object.defineProperty(obj,\"2\",&#123; configurable:false&#125;)// 测试是否可以被删除delete obj[\"2\"]obj[\"2\"] = \"可以修改？\"console.log(obj)try&#123;//捕获错误 Object.defineProperty(obj,\"2\",&#123; configurable:true &#125;)&#125;catch(err)&#123; console.dir(err)&#125;delete obj[\"2\"]console.log(obj) 输出结果： 由图可以得出，当configurable设置为false的时候，属性值不可以被删除，并且不可以再次修改特性，如果修改会报错，但是属性的值依旧可以改变。","categories":[],"tags":[]},{"title":"element-ui树表格懒加载动态更新数据","slug":"element-ui树表格懒加载动态更新数据","date":"2020-07-16T09:53:35.126Z","updated":"2020-07-16T09:56:15.518Z","comments":true,"path":"2020/07/16/element-ui树表格懒加载动态更新数据/","link":"","permalink":"http://yoursite.com/2020/07/16/element-ui%E6%A0%91%E8%A1%A8%E6%A0%BC%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195&lt;template&gt; &lt;div class=\"home\"&gt; &lt;div class=\"app-page-header\"&gt;&lt;/div&gt; &lt;div class=\"app-page-content deepBox\"&gt; &lt;el-table ref=\"table\" :data=\"tableData\" style=\"width: 100%;margin-bottom: 20px;\" row-key=\"areaId\" border :load=\"load\" :lazy=\"true\" :tree-props=\"&#123;children: 'children', hasChildren:'hasChildren'&#125;\" &gt; &lt;!-- :expand-row-keys=\"expandRowKeys\" --&gt; &lt;el-table-column width=\"60\" align=\"center\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;span v-show=\"!scope.row.hasChildren\"&gt;-&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"name\" label=\"区域名称\" width=\"100\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-link type=\"primary\" @click=\"$router.push(`serverList/$&#123;scope.row.areaId&#125;`)\" &gt;&#123;&#123;scope.row.name&#125;&#125;&lt;/el-link&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"childCount\" label=\"子区域数\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"dnai\" label=\"标识符\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"ruleCount\" label=\"服务器数\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"createdAt\" label=\"加入时间\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"ruleCount\" label=\"关联策略数\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"ruleCount\" label=\"操作\" width=\"200\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-button-group&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\" size=\"mini\" @click=\"addReg(scope.row)\"&gt;&lt;/el-button&gt; &lt;el-button type=\"danger\" icon=\"el-icon-close\" size=\"mini\" @click=\"del(scope.row)\"&gt;&lt;/el-button&gt; &lt;el-button type=\"primary\" icon=\"el-icon-edit\" size=\"mini\" @click=\"edit(scope.row)\"&gt;&lt;/el-button&gt; &lt;el-button type=\"primary\" icon=\"el-icon-tickets\" size=\"mini\"&gt;&lt;/el-button&gt; &lt;/el-button-group&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;addRegional :dialogVisible.sync=\"regionalAddVisible\" :parentList=\"tableData\" :regIdVal=\"regIdVal\" @sonAddEvent=\"sonAddEvent\" :edit=\"isEdit\" ref=\"addReg\" &gt;&lt;/addRegional&gt; &lt;addServer :dialogVisible.sync=\"serverAddVisible\"&gt;&lt;/addServer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import &#123; Component, Vue &#125; from \"vue-property-decorator\";import PageHead from \"@/components/PageHead/index.vue\";import addRegional from \"./components/addRegional.vue\";import addServer from \"./components/addServer.vue\";import &#123; resource_areas_add &#125; from \"@/api/regionalManagement\";import &#123; resource_areas_list, resource_areas_del&#125; from \"@/api/regionalManagement\";@Component(&#123; name: \"RegionalManagement\", components: &#123; PageHead, addRegional, addServer &#125;&#125;)export default class RegionalManagement extends Vue &#123; $refs!: &#123; table: HTMLFormElement; addReg: HTMLFormElement; &#125;; currentPage1 = 1; regionalAddVisible = false; serverAddVisible = false; expandRowKeys: number[] = []; tableData: any = []; total: number = 0; maps = new Map(); //缓存数据 RowObject:any = &#123;&#125;; //标记操作行对象 isEdit:boolean=false; regIdVal = &#123; id: \"\", val: \"\" &#125;; created() &#123; this.getList(); &#125; //请求列表 async getList(pid: number = 0) &#123; let res = await resource_areas_list(&#123; parentId: pid &#125;); this.tableData = this.addHasChildren(res.areas); this.maps.set(0,this.tableData) console.log(this.maps) console.log(this.tableData); &#125; //添加树区域符号判断 addHasChildren(arr: any) &#123; return arr.map((item: any) =&gt; Object.assign(item, &#123; hasChildren: item.childCount &gt; 0 &#125;) ); &#125; //懒加载数据点击加号触发 async load(tree: any, treeNode: Object, resolve: Function) &#123; let areaId = tree.areaId; //保存数据，参数1是当前展开的id作为标识符便于查找，参数2是对应的对象 this.maps.set(areaId, tree); console.log(this.maps); let res = await resource_areas_list(&#123; parentId: tree.areaId &#125;); let arr = this.addHasChildren(res.areas); resolve(res.areas); &#125; //删除 async del(object: any) &#123; let p = await this.$confirm(\"确认删除该区域吗?\", \"提示\", &#123; confirmButtonText: \"确定\", cancelButtonText: \"取消\", type: \"warning\" &#125;); if (p == \"confirm\") &#123; let res = await resource_areas_del(&#123; areaId: object.areaId &#125;); this.$message(&#123; type: \"success\", message: \"删除成功!\" &#125;); //删除的时候找父节点更新本身列表，然后找到父节点的父节点更新自己本身 //需要更新父所以从缓存的地方找到父的父节点去更新父 let parentId = this.maps.get(object.parentId).parentId //更新父节点从而触发本身所在数组发生变化 let areaId = this.maps.get(object.parentId).areaId this.upData(areaId,parentId) &#125; &#125; //获取子组件返回数据，然后进行添加 async sonAddEvent(from_date: any) &#123; //提交请求 let res = await resource_areas_add(from_date); //关闭组件 this.regionalAddVisible = false; this.$message(&#123; type: \"success\", message: \"添加成功!\" &#125;); let areaId = this.RowObject.areaId//获取添加行的id let parentId = this.RowObject.parentId?this.RowObject.parentId:0//获取操作行的父id this.upData(areaId,parentId);//通过子父节点更新数据 &#125; async upData(id: number, pid?: number) &#123; //更新父 if (pid) &#123; console.log(\"有父节点\") let res = await resource_areas_list(&#123; parentId: pid &#125;); let list = this.addHasChildren(res.areas) this.$set(this.$refs.table.store.states.lazyTreeNodeMap, pid, list); &#125;else&#123; console.log(\"没有父节点所以重新请求列表\") this.getList(); &#125; //更新子 if (this.maps.has(id)) &#123; console.log(\"更新子节点数组,id是\"+id) let res = await resource_areas_list(&#123; parentId: id &#125;); //再次请求获取当前数据 let list = this.addHasChildren(res.areas)//处理数据 this.$set(this.$refs.table.store.states.lazyTreeNodeMap, id, list);//将当前数据重新push &#125;else&#123;//如果最外层更新顶级 console.log(\"最外层，所以更新父节点\") this.getList(); &#125; &#125; edit(object: any) &#123; this.regionalAddVisible = true; this.isEdit = true &#125; addReg(object: any) &#123; //给子组件传值 this.regionalAddVisible = true; if (!object) &#123; this.RowObject = &#123;&#125;; this.regIdVal.id = \"\"; this.regIdVal.val = \"\"; return; &#125; this.RowObject = object; //获取行id存储 this.regIdVal.id = object.areaId; this.regIdVal.val = object.name; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;&lt;/style&gt;","categories":[],"tags":[]},{"title":"简单版Promise封装","slug":"简单版Promise封装","date":"2020-07-07T06:37:48.729Z","updated":"2020-07-07T06:43:40.362Z","comments":true,"path":"2020/07/07/简单版Promise封装/","link":"","permalink":"http://yoursite.com/2020/07/07/%E7%AE%80%E5%8D%95%E7%89%88Promise%E5%B0%81%E8%A3%85/","excerpt":"","text":"函数作为参数传给函数123456789function Pro(fn)&#123;//1首先声明了一个pro函数,pro函数接收一个函数作为参数 var value = 100 fn(value)//3然后再Pro里面执行了传递过来的函数，并且给此函数传递了一个参数，这样就可以在Pro执行的时候拿到里面的数据&#125;Pro(function(value)&#123;//2然后我们执行pro函数，传递给它一个匿名函数 console.log(\"fn执行了\") console.log(\"value是:\"+value)&#125;) 首先声明了一个pro函数,pro函数接收一个函数作为参数 然后我们执行pro函数，传递给它一个匿名函数 然后再Pro里面执行了传递过来的函数，并且给此函数传递了一个参数，这样就可以在Pro执行的时候拿到里面的数据 构造函数版本12345678910111213function Pro(fn) &#123;//1首先声明了一个pro构造函数,pro构造函数接收一个函数作为参数 this.init(fn)//3.初始化&#125;Pro.prototype = &#123; constructor: Pro, init(fn) &#123; fn(5000)//4执行实例化传递过来的fn方法并且穿一个实参5000 &#125;&#125;let p = new Pro(function (res) &#123;//2实例化Pro传递一个函数作为参数 //假设我们现在需要在这里拿到res的值 console.log(res)&#125;) 加入异步操作123456789101112131415161718function Pro(fn)&#123; this.init(fn)&#125;Pro.prototype=&#123; constructor:Pro, init(fn)&#123; fn(this.res)//4.改变执行时的传惨，把res方法传递给实例化对象 &#125;, res(value)&#123;//3.定义一个res方法 console.log(value) &#125;&#125;let p = new Pro(function(res)&#123; setTimeout(function()&#123;//1.改写为异步操作并且执行res,那么这次的res就不是数值，也是一个函数了 var vlue = parseInt(Math.random()*500) res(vlue)//2.我们现在执行这个函数，这样就可以在异步里面拿到这个参数 &#125;,1000)&#125;) 现在我们需要在构造函数里拿到异步操作之后的值，假设setTimeout是一个网络请求，value是网网络请求之后的结果 此时的res就是构造函数的res,我们在初始化的时候执行fn方法,然后把res方法作为参数传递给实例化对象的函数的参数了。 然后执行res方法,把vlaue传递给构造函数，此时就可以在构造函数里面的res方法里拿到value的值了 用.then来实现链式调用123456789101112131415161718192021222324function Pro(fn)&#123; this.init(fn)&#125;Pro.prototype=&#123; constructor:Pro, fns:[], init(fn)&#123; fn(this.res.bind(this)) &#125;, res(value)&#123; this.fns.forEach(fns=&gt;fns(value)) &#125;, then(res)&#123; this.fns.push(res) &#125;&#125;let p = new Pro(function(res)&#123; setTimeout(function()&#123; var vlue = parseInt(Math.random()*500) res(vlue) &#125;,1000)&#125;).then(res=&gt;&#123; console.log(res)&#125;) .then接收的也是一个函数，但是我们是异步执行的，所以每次.then的时候用一个数组把传递过去的方法存起来，然后在res执行的时候执行传递过去的.then方法并且把vlaue传过去。这样就实现了链式调用。","categories":[],"tags":[]},{"title":"vue-axios跨域请求方法","slug":"vue-axios跨域请求方法","date":"2020-06-15T09:51:27.875Z","updated":"2020-06-15T15:05:23.663Z","comments":true,"path":"2020/06/15/vue-axios跨域请求方法/","link":"","permalink":"http://yoursite.com/2020/06/15/vue-axios%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/","excerpt":"","text":"vue-axios跨域 基本环境 *”axios”*: “^0.19.2”, *”body-parser”*: “^1.19.0”, *”cookie-parser”*: “^1.4.5”, *”echarts”*: “^4.8.0”, *”element-ui”*: “^2.13.2”, *”express”*: “^4.17.1”, *”multer”*: “^1.4.2”, *”vue”*: “^2.5.2”, *”vue-axios”*: “^2.1.5”, *”vue-router”*: “^3.0.1” 示例接口： 本地端口：http://localhost:8083/ 跨域端口：https://iflow-api.uc.cn/feiyan/special（此接口是新冠病毒数据接口地址） 解决方案 第一步来到 main.js 中，加入以下配置项： 1234567891011121314151617181920212223242526import Vue from 'vue'import App from './App'import router from './router'import ElementUI from 'element-ui';import ajax from '@/request/ajax'import 'element-ui/lib/theme-chalk/index.css';import echarts from 'echarts';Vue.prototype.$ajax = ajax//跨域配置,此地的ajax只是一个命名,实际上是自己做过修改的axiosajax.defaults.baseURL = '/api'ajax.defaults.headers.post['Content-Type'] = 'application/json';Vue.config.productionTip = falseVue.prototype.$echarts = echarts;Vue.use(ElementUI, &#123; size: 'medium', zIndex: 2000&#125;);/* eslint-disable no-new */new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) 配置 config 文件下的 index.js ，找到 proxyTable 在此对象中加入以下代码： 123456'/api': &#123; target:'https://iflow-api.uc.cn/feiyan', // 你请求的第三方接口 changeOrigin:true, // 在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRewrite:&#123; // 路径重写， '^/api': '' // 替换target中的请求地址，也就是说以后你在请求`https://iflow-api.uc.cn/feiyan/XXXXX这个地址的时候直接写成/xxxx即可。 &#125; 请求示例： 12345678910111213141516//本来请求地址是https://iflow-api.uc.cn/feiyan/special,现在只用写/specialthis.$ajax.get('/special',&#123; 'uc_param_str': 'pccplomi', 'feiyan': '1', 'district': '1', 'tabStart': '0', 'tabEnd': '1', 'tabBrief':'1', 'aid': '3804775841868884355' &#125;).then(res=&gt;&#123;//处理数据 this.list = res.data.data.feiyan.provinces.map(item=&gt;&#123; return Object.assign(item,&#123;sum:item.sure_cnt-item.die_cnt-item.cure_cnt&#125;) &#125;).sort((item,item2)=&gt;&#123; return item2.sure_cnt-item.sure_cnt &#125;) &#125;) 然后执行请求可以看到本来是https://iflow-api.uc.cn/feiyan/special的现在变成了http://localhost:8083/api/special 也就是说经过这个配置 api替换了config文件下 index.js中target值的地址去开启一个代理，然后访问此路径下的所有接口都只用从https://iflow-api.uc.cn/feiyan/special之后开使写就行了。","categories":[],"tags":[]},{"title":"npm常用方式","slug":"npm常用方式","date":"2020-06-13T10:32:07.732Z","updated":"2020-06-13T10:31:45.375Z","comments":true,"path":"2020/06/13/npm常用方式/","link":"","permalink":"http://yoursite.com/2020/06/13/npm%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/","excerpt":"","text":"npm使用方式1.npm常用命令 npm init npm init -y //可以跳过向导，快速生成 npm install npm install //一次性把 dependencies选项中的依赖全部安装 npm install 包名 npm install 包名 –save //下载并且保存依赖 简写:npm i 包名 -S 或者npm i -S 包名 npm uninstall 包名 只删除，如果有依赖项依然会保存 npm uninstall –save 包名 删除同时把依赖信息也去除 简写：npm un -S 包名 npm help npm install help //查看install使用帮助 解决 npm 被墙的问题npm 的存储包放在国外，有时候会被墙，所以下载速度很慢，可以下载 cnpm解决 安装淘宝的cnpm(在任意目录下都可以): 1npm install -g cnpm --registry=https://registry.npm.taobao.org 接下来你安装包的时候把之前的 npm 替换成 cnpm 使用案例，比如安装jquery： 123npm i jquery//变为cnpm i jquery 如果不想安装 cnpm 又想使用淘宝的服务器来下载: 1npm install jquery --registry=https://registry.npm.taobao.org 但是每次都这样手动去加很麻烦，我们可以把这个选项加入配置文件中： 1npm config set registry=https://registry.npm.taobao.org 安装完成之后使用 npm config list 查看配置信息，成功后你使用所有的 npm install 都会使用淘宝的服务器来下载。","categories":[],"tags":[]}],"categories":[],"tags":[]}